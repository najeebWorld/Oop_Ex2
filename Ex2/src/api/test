package api;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import java.io.PrintWriter;
import java.util.*;
import java.util.Iterator;
import java.util.List;

public class DWGA implements DirectedWeightedGraphAlgorithms {
    private DWG graph;
    private int index; //idx of Tarjan algoritm
    private HashMap<Integer,Double[]> nodesShortestPath;

    public DWGA(DWG gr){
        this.graph = gr;
        this.index = 0;
        Iterator<NodeData> i = gr.nodeIter();
        this.nodesShortestPath = new HashMap<Integer,Double[]>();
        while (i.hasNext()){
            this.nodesShortestPath.put(i.next().getKey(),new Double[gr.nodeSize()]);
        }
        fillTheArr();
    }


    @Override
    public void init(DirectedWeightedGraph g) {
        this.graph = (DWG) g;
        this.nodesShortestPath = new HashMap<Integer,Double[]>();
        Iterator<NodeData> i = g.nodeIter();
        while (i.hasNext()){
            this.nodesShortestPath.put(i.next().getKey(),new Double[g.nodeSize()]);
        }
        fillTheArr();
    }

    private void fillTheArr() {
        Iterator<NodeData> i = this.graph.nodeIter();
        while (i.hasNext()){
            Iterator<NodeData> j = this.graph.nodeIter();
            NodeData node=i.next();
            while (j.hasNext()){
                NodeData node2 = j.next();
                Double[] arr = this.nodesShortestPath.get(node.getKey());
                if (node.getKey() != node2.getKey()) {
                    Double insert = shortestPathDistToTheInit(node.getKey(), node2.getKey());
                        arr[node2.getKey()] = insert;
                }
                else{
                    arr[node2.getKey()] = 0.0;
                }
            }
        }
    }


    @Override
    public DirectedWeightedGraph getGraph() {
        return this.graph;
    }

    @Override
    public DirectedWeightedGraph copy() {
        DWG here = new DWG();
        Iterator<NodeData> it = this.graph.nodeIter();
        while (it.hasNext()) {
            Node_Data k = new Node_Data(it.next().getKey(), (Geo_Location) it.next().getLocation());
            here.addNode(k);
        }
        Iterator<NodeData> it2 = this.graph.nodeIter();
        while (it2.hasNext()) {
            Iterator<EdgeData> it3 = this.graph.edgeIter(it2.next().getKey());
            while (it3.hasNext()) {
                here.connect(it3.next().getSrc(), it3.next().getDest(), it3.next().getWeight());
            }
        }
        return here;
    }

    @Override
    public boolean isConnected() {
        for (Integer i: this.nodesShortestPath.keySet()){
            Double[] here= this.nodesShortestPath.get(i);
            for (int  j = 0;  j < here.length;  j++) {
                if (i==j){
                    continue;
                }
                if (here[j]==-1){
                    return false;
                }
            }
        }
        return true;
//        Stack<Node_Data> nodesPerComponent = new Stack<>();
//        Iterator<NodeData> it = this.graph.nodeIter();
//        while (it.hasNext()) {
//            Node_Data n = (Node_Data) it.next();
//            if (n.index == -1) {
//                strongConnect(n, nodesPerComponent);
//            }
//        }
//        return false;
    }

    private void strongConnect(Node_Data node, Stack<Node_Data> ourStack) {
        node.index = this.index;
        node.lowlink = this.index;
        this.index++;
        ourStack.add(node);
        node.onStack = true;

        Iterator<EdgeData> iter = this.graph.edgeIter(node.getKey());
        while (iter.hasNext()) {
            Edge_Data e = (Edge_Data) iter.next();
            Node_Data w = (Node_Data) this.graph.getNode(e.getDest());
            if (w.index == -1) {
                strongConnect(w, ourStack);
                node.lowlink = Math.min(node.lowlink, w.lowlink);
            } else if (w.onStack) {
                node.lowlink = Math.min(node.lowlink, w.index);
            }
        }
        if (node.index == node.lowlink) {
            Node_Data w;
            do {
                w = ourStack.pop();

            } while (!node.equals(w));
        }

    }

    public double shortestPathDistToTheInit(int src, int dest) {
        Queue<NodeData> q = new ArrayDeque<>();
        q.add(graph.getNode(src));
        // List<Double> weight= new LinkedList<>();
        HashMap<Integer, Double> weight = new HashMap<Integer, Double>();
        Iterator<NodeData> n = graph.nodeIter();
        for (int i = 0; i < graph.nodeSize(); i++) {
            NodeData n1 = n.next();
            if (n1.getKey() != src) {
                weight.put(n1.getKey(), Double.MAX_VALUE);
            }
        }
        weight.put(src, 0.0);
        while (!q.isEmpty()) {
            NodeData discover = q.poll();
            Iterator<EdgeData> edge_node = this.graph.edgeIter(discover.getKey());
            while (edge_node.hasNext()) {
                EdgeData edge = edge_node.next();
                if (weight.get(edge.getDest()) > weight.get(discover.getKey()) + edge.getWeight()) {
                    weight.put(edge.getDest(), weight.get(discover.getKey()) + edge.getWeight());
                    q.add(graph.getNode(edge.getDest()));
                }
            }
        }
        return weight.get(dest);
    }

    @Override
    public double shortestPathDist(int src, int dest) {
        return this.nodesShortestPath.get(src)[dest];
//        Queue<NodeData> q = new ArrayDeque<>();
//        q.add(graph.getNode(src));
//        // List<Double> weight= new LinkedList<>();
//        HashMap<Integer, Double> weight = new HashMap<Integer, Double>();
//        Iterator<NodeData> n = graph.nodeIter();
//        for (int i = 0; i < graph.nodeSize(); i++) {
//            NodeData n1 = n.next();
//            if (n1.getKey() != src) {
//                weight.put(n1.getKey(), Double.MAX_VALUE);
//            }
//        }
//        weight.put(src, 0.0);
//        while (!q.isEmpty()) {
//            NodeData discover = q.poll();
//            Iterator<EdgeData> edge_node = this.graph.edgeIter(discover.getKey());
//            while (edge_node.hasNext()) {
//                EdgeData edge = edge_node.next();
//                if (weight.get(edge.getDest()) > weight.get(discover.getKey()) + edge.getWeight()) {
//                    weight.put(edge.getDest(), weight.get(discover.getKey()) + edge.getWeight());
//                    q.add(graph.getNode(edge.getDest()));
//                }
//            }
//        }
//        return weight.get(dest);
    }

    @Override
    public List<NodeData> shortestPath(int src, int dest) {
        HashMap<Integer, Double> weight = BFS_weight(src, dest);
        //  Iterator<Integer> edge_to_dest = graph.toMe().get(dest).values().iterator();
        List<NodeData> return_node = new ArrayList<>();
        NodeData n = graph.getNode(src);
        return_node.add(n);
        Geo_Location X = new Geo_Location(1, 1, 2);
        n = new Node_Data(-1, X);
        while (n.getKey() != src) {
            double min = Double.MAX_VALUE;
            int what_in = Integer.MAX_VALUE;
            Iterator<Integer> edge_to_dest = graph.toMe.get(dest).values().iterator();
            while (edge_to_dest.hasNext()) {
                int node = edge_to_dest.next();
                if (node == src) {
                    what_in = src;
                    break;
                }
                if (min > weight.get(node)) {
                    min = weight.get(node);
                    what_in = node;
                }

            }
            dest = what_in;
            n = graph.getNode(what_in);
            return_node.add(n);
        }
        Collections.reverse(return_node);
        return return_node;
    }

    @Override
    public NodeData center() {
        if (isConnected() == false){
            return null;
        }
        double minFromMax = Double.MAX_VALUE;
        NodeData ans = null;
        for (Integer i:this.nodesShortestPath.keySet()){
            Double[] arr = this.nodesShortestPath.get(i);
            double max = 0;
            for (int j = 0; j < arr.length; j++) {
                if (arr[j] > max){
                    max = arr[j];
                }
            }
            if(max<minFromMax){
                minFromMax = max;
                ans = this.graph.getNode(i);
            }
        }
        return ans;
    }

    @Override
    public List<NodeData> tsp(List<NodeData> cities) {
        return null;
    }

    @Override
    public boolean save(String file) {
        try {
            JSONObject jo = new JSONObject();
            JSONArray ja = new JSONArray();
            Map m;
            Iterator<EdgeData> iterator = this.graph.edgeIter();
            while (iterator.hasNext()) {
                m = new LinkedHashMap(3);
                EdgeData e = iterator.next();
                m.put("src", e.getSrc());
                m.put("w", e.getWeight());
                m.put("dest", e.getDest());
                ja.add(m);
            }
            jo.put("Edges", ja);
            ja = new JSONArray();
            Iterator<NodeData> iterator1 = this.graph.nodeIter();
            while (iterator1.hasNext()) {
                m = new LinkedHashMap(2);
                NodeData n = iterator1.next();
                m.put("pos", n.getLocation().x() + "," + n.getLocation().y() + "," + n.getLocation().z());
                m.put("id", n.getKey());
                ja.add(m);
            }
            jo.put("Nodes", ja);
            PrintWriter pw = new PrintWriter(file);
            pw.write(jo.toJSONString());
            pw.flush();
            pw.close();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public boolean load(String file) {
        try {
            this.graph = new DWG(file);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public HashMap<Integer, Double> BFS_weight(int src, int dest) {
        Queue<NodeData> q = new ArrayDeque<>();
        q.add(graph.getNode(src));
        // List<Double> weight= new LinkedList<>();
        HashMap<Integer, Double> weight = new HashMap<Integer, Double>();
        Iterator<NodeData> n = graph.nodeIter();
        for (int i = 0; i < graph.nodeSize(); i++) {
            NodeData n1 = n.next();
            if (n1.getKey() != src) {
                weight.put(n1.getKey(), Double.MAX_VALUE);
            }
        }
        weight.put(src, 0.0);
        while (!q.isEmpty()) {
            NodeData discover = q.poll();
            Iterator<EdgeData> edge_node = this.graph.edgeIter(discover.getKey());
            while (edge_node.hasNext()) {
                EdgeData edge = edge_node.next();
                if (weight.get(edge.getDest()) > weight.get(discover.getKey()) + edge.getWeight()) {
                    weight.put(edge.getDest(), weight.get(discover.getKey()) + edge.getWeight());
                    q.add(graph.getNode(edge.getDest()));
                }
            }
        }
        return weight;
    }
}